From a32d4a72fd084aab158f236b64c73e8349d8843f Mon Sep 17 00:00:00 2001
From: Ivan Mironov <mironov.ivan@gmail.com>
Date: Fri, 18 Oct 2024 22:55:10 +0200
Subject: [PATCH 1/4] Propagate context for rule matching

---
 adapter/router.go                             |  8 ++---
 cmd/sing-box/cmd_rule_set_match.go            |  3 +-
 .../convertor/adguard/convertor_test.go       | 31 ++++++++++++-------
 route/router.go                               | 10 +++---
 route/router_dns.go                           |  8 ++---
 route/rule_abstract.go                        | 21 +++++++------
 route/rule_default.go                         |  4 ++-
 route/rule_dns.go                             | 21 +++++++------
 route/rule_item_adguard.go                    |  3 +-
 route/rule_item_auth_user.go                  |  3 +-
 route/rule_item_cidr.go                       |  3 +-
 route/rule_item_clash_mode.go                 |  3 +-
 route/rule_item_client.go                     |  3 +-
 route/rule_item_domain.go                     |  3 +-
 route/rule_item_domain_keyword.go             |  3 +-
 route/rule_item_domain_regex.go               |  3 +-
 route/rule_item_geoip.go                      |  3 +-
 route/rule_item_geosite.go                    |  5 +--
 route/rule_item_inbound.go                    |  3 +-
 route/rule_item_ip_is_private.go              |  3 +-
 route/rule_item_ipversion.go                  |  4 ++-
 route/rule_item_network.go                    |  3 +-
 route/rule_item_outbound.go                   |  3 +-
 route/rule_item_package_name.go               |  3 +-
 route/rule_item_port.go                       |  3 +-
 route/rule_item_port_range.go                 |  3 +-
 route/rule_item_process_name.go               |  3 +-
 route/rule_item_process_path.go               |  3 +-
 route/rule_item_process_path_regex.go         |  3 +-
 route/rule_item_protocol.go                   |  3 +-
 route/rule_item_query_type.go                 |  3 +-
 route/rule_item_rule_set.go                   |  5 +--
 route/rule_item_user.go                       |  3 +-
 route/rule_item_user_id.go                    |  3 +-
 route/rule_item_wifi_bssid.go                 |  3 +-
 route/rule_item_wifi_ssid.go                  |  3 +-
 route/rule_set_local.go                       |  4 +--
 route/rule_set_remote.go                      |  4 +--
 38 files changed, 122 insertions(+), 81 deletions(-)

diff --git a/adapter/router.go b/adapter/router.go
index 619c1110cb1b..75850b2f405d 100644
--- a/adapter/router.go
+++ b/adapter/router.go
@@ -6,8 +6,8 @@ import (
 	"net/netip"
 
 	"github.com/sagernet/sing-box/common/geoip"
-	"github.com/sagernet/sing-dns"
-	"github.com/sagernet/sing-tun"
+	dns "github.com/sagernet/sing-dns"
+	tun "github.com/sagernet/sing-tun"
 	"github.com/sagernet/sing/common/control"
 	N "github.com/sagernet/sing/common/network"
 	"github.com/sagernet/sing/common/x/list"
@@ -75,7 +75,7 @@ func RouterFromContext(ctx context.Context) Router {
 }
 
 type HeadlessRule interface {
-	Match(metadata *InboundContext) bool
+	Match(ctx context.Context, metadata *InboundContext) bool
 	String() string
 }
 
@@ -93,7 +93,7 @@ type DNSRule interface {
 	RewriteTTL() *uint32
 	ClientSubnet() *netip.Prefix
 	WithAddressLimit() bool
-	MatchAddressLimit(metadata *InboundContext) bool
+	MatchAddressLimit(ctx context.Context, metadata *InboundContext) bool
 }
 
 type RuleSet interface {
diff --git a/cmd/sing-box/cmd_rule_set_match.go b/cmd/sing-box/cmd_rule_set_match.go
index 937458f2c680..d1ddcc245c13 100644
--- a/cmd/sing-box/cmd_rule_set_match.go
+++ b/cmd/sing-box/cmd_rule_set_match.go
@@ -2,6 +2,7 @@ package main
 
 import (
 	"bytes"
+	"context"
 	"io"
 	"os"
 
@@ -88,7 +89,7 @@ func ruleSetMatch(sourcePath string, domain string) error {
 		if err != nil {
 			return E.Cause(err, "parse rule_set.rules.[", i, "]")
 		}
-		if currentRule.Match(&metadata) {
+		if currentRule.Match(adapter.WithContext(context.Background(), &metadata), &metadata) {
 			println(F.ToString("match rules.[", i, "]: ", currentRule))
 		}
 	}
diff --git a/cmd/sing-box/internal/convertor/adguard/convertor_test.go b/cmd/sing-box/internal/convertor/adguard/convertor_test.go
index 7da8a228416b..c848f58d5382 100644
--- a/cmd/sing-box/internal/convertor/adguard/convertor_test.go
+++ b/cmd/sing-box/internal/convertor/adguard/convertor_test.go
@@ -1,6 +1,7 @@
 package adguard
 
 import (
+	"context"
 	"strings"
 	"testing"
 
@@ -65,14 +66,16 @@ example.arpa
 		"sing-box.sagernet.org",
 	}
 	for _, domain := range matchDomain {
-		require.True(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.True(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 	for _, domain := range notMatchDomain {
-		require.False(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.False(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 }
 
@@ -96,14 +99,16 @@ func TestHosts(t *testing.T) {
 		"localhost",
 	}
 	for _, domain := range matchDomain {
-		require.True(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.True(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 	for _, domain := range notMatchDomain {
-		require.False(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.False(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 }
 
@@ -128,13 +133,15 @@ www.example.org
 		"example.org",
 	}
 	for _, domain := range matchDomain {
-		require.True(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.True(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 	for _, domain := range notMatchDomain {
-		require.False(t, rule.Match(&adapter.InboundContext{
+		metadata := adapter.InboundContext{
 			Domain: domain,
-		}), domain)
+		}
+		require.False(t, rule.Match(adapter.WithContext(context.Background(), &metadata), &metadata), domain)
 	}
 }
diff --git a/route/router.go b/route/router.go
index c8fe94be5b89..4f46273605a8 100644
--- a/route/router.go
+++ b/route/router.go
@@ -26,10 +26,10 @@ import (
 	"github.com/sagernet/sing-box/option"
 	"github.com/sagernet/sing-box/outbound"
 	"github.com/sagernet/sing-box/transport/fakeip"
-	"github.com/sagernet/sing-dns"
-	"github.com/sagernet/sing-mux"
-	"github.com/sagernet/sing-tun"
-	"github.com/sagernet/sing-vmess"
+	dns "github.com/sagernet/sing-dns"
+	mux "github.com/sagernet/sing-mux"
+	tun "github.com/sagernet/sing-tun"
+	vmess "github.com/sagernet/sing-vmess"
 	"github.com/sagernet/sing/common"
 	"github.com/sagernet/sing/common/buf"
 	"github.com/sagernet/sing/common/bufio"
@@ -1150,7 +1150,7 @@ func (r *Router) match0(ctx context.Context, metadata *adapter.InboundContext, d
 	}
 	for i, rule := range r.rules {
 		metadata.ResetRuleCache()
-		if rule.Match(metadata) {
+		if rule.Match(ctx, metadata) {
 			detour := rule.Outbound()
 			r.logger.DebugContext(ctx, "match[", i, "] ", rule.String(), " => ", detour)
 			if outbound, loaded := r.Outbound(detour); loaded {
diff --git a/route/router_dns.go b/route/router_dns.go
index ead8c2894301..40477adb4bd6 100644
--- a/route/router_dns.go
+++ b/route/router_dns.go
@@ -8,7 +8,7 @@ import (
 	"time"
 
 	"github.com/sagernet/sing-box/adapter"
-	"github.com/sagernet/sing-dns"
+	dns "github.com/sagernet/sing-dns"
 	"github.com/sagernet/sing/common/cache"
 	E "github.com/sagernet/sing/common/exceptions"
 	F "github.com/sagernet/sing/common/format"
@@ -51,7 +51,7 @@ func (r *Router) matchDNS(ctx context.Context, allowFakeIP bool, index int, isAd
 				continue
 			}
 			metadata.ResetRuleCache()
-			if rule.Match(metadata) {
+			if rule.Match(ctx, metadata) {
 				detour := rule.Outbound()
 				transport, loaded := r.transportMap[detour]
 				if !loaded {
@@ -137,7 +137,7 @@ func (r *Router) Exchange(ctx context.Context, message *mDNS.Msg) (*mDNS.Msg, er
 						return false
 					}
 					metadata.DestinationAddresses = addresses
-					return rule.MatchAddressLimit(metadata)
+					return rule.MatchAddressLimit(ctx, metadata)
 				})
 			} else {
 				addressLimit = false
@@ -219,7 +219,7 @@ func (r *Router) Lookup(ctx context.Context, domain string, strategy dns.DomainS
 			addressLimit = true
 			responseAddrs, err = r.dnsClient.LookupWithResponseCheck(dnsCtx, transport, domain, strategy, func(responseAddrs []netip.Addr) bool {
 				metadata.DestinationAddresses = responseAddrs
-				return rule.MatchAddressLimit(metadata)
+				return rule.MatchAddressLimit(ctx, metadata)
 			})
 		} else {
 			addressLimit = false
diff --git a/route/rule_abstract.go b/route/rule_abstract.go
index 9ef2e93277d0..a9e9d4a19530 100644
--- a/route/rule_abstract.go
+++ b/route/rule_abstract.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"io"
 	"strings"
 
@@ -63,7 +64,7 @@ func (r *abstractDefaultRule) UpdateGeosite() error {
 	return nil
 }
 
-func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
+func (r *abstractDefaultRule) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if len(r.allItems) == 0 {
 		return true
 	}
@@ -71,7 +72,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 	if len(r.sourceAddressItems) > 0 && !metadata.SourceAddressMatch {
 		metadata.DidMatch = true
 		for _, item := range r.sourceAddressItems {
-			if item.Match(metadata) {
+			if item.Match(ctx, metadata) {
 				metadata.SourceAddressMatch = true
 				break
 			}
@@ -81,7 +82,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 	if len(r.sourcePortItems) > 0 && !metadata.SourcePortMatch {
 		metadata.DidMatch = true
 		for _, item := range r.sourcePortItems {
-			if item.Match(metadata) {
+			if item.Match(ctx, metadata) {
 				metadata.SourcePortMatch = true
 				break
 			}
@@ -91,7 +92,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 	if len(r.destinationAddressItems) > 0 && !metadata.DestinationAddressMatch {
 		metadata.DidMatch = true
 		for _, item := range r.destinationAddressItems {
-			if item.Match(metadata) {
+			if item.Match(ctx, metadata) {
 				metadata.DestinationAddressMatch = true
 				break
 			}
@@ -101,7 +102,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 	if !metadata.IgnoreDestinationIPCIDRMatch && len(r.destinationIPCIDRItems) > 0 && !metadata.DestinationAddressMatch {
 		metadata.DidMatch = true
 		for _, item := range r.destinationIPCIDRItems {
-			if item.Match(metadata) {
+			if item.Match(ctx, metadata) {
 				metadata.DestinationAddressMatch = true
 				break
 			}
@@ -111,7 +112,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 	if len(r.destinationPortItems) > 0 && !metadata.DestinationPortMatch {
 		metadata.DidMatch = true
 		for _, item := range r.destinationPortItems {
-			if item.Match(metadata) {
+			if item.Match(ctx, metadata) {
 				metadata.DestinationPortMatch = true
 				break
 			}
@@ -122,7 +123,7 @@ func (r *abstractDefaultRule) Match(metadata *adapter.InboundContext) bool {
 		if _, isRuleSet := item.(*RuleSetItem); !isRuleSet {
 			metadata.DidMatch = true
 		}
-		if !item.Match(metadata) {
+		if !item.Match(ctx, metadata) {
 			return r.invert
 		}
 	}
@@ -217,16 +218,16 @@ func (r *abstractLogicalRule) Close() error {
 	return nil
 }
 
-func (r *abstractLogicalRule) Match(metadata *adapter.InboundContext) bool {
+func (r *abstractLogicalRule) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.mode == C.LogicalTypeAnd {
 		return common.All(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.Match(metadata)
+			return it.Match(ctx, metadata)
 		}) != r.invert
 	} else {
 		return common.Any(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.Match(metadata)
+			return it.Match(ctx, metadata)
 		}) != r.invert
 	}
 }
diff --git a/route/rule_default.go b/route/rule_default.go
index 40b93e5f9650..6f38fa54a730 100644
--- a/route/rule_default.go
+++ b/route/rule_default.go
@@ -1,6 +1,8 @@
 package route
 
 import (
+	"context"
+
 	"github.com/sagernet/sing-box/adapter"
 	C "github.com/sagernet/sing-box/constant"
 	"github.com/sagernet/sing-box/log"
@@ -38,7 +40,7 @@ type DefaultRule struct {
 }
 
 type RuleItem interface {
-	Match(metadata *adapter.InboundContext) bool
+	Match(ctx context.Context, metadata *adapter.InboundContext) bool
 	String() string
 }
 
diff --git a/route/rule_dns.go b/route/rule_dns.go
index 616f956aaf09..57a031c5f187 100644
--- a/route/rule_dns.go
+++ b/route/rule_dns.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"net/netip"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -262,16 +263,16 @@ func (r *DefaultDNSRule) WithAddressLimit() bool {
 	return false
 }
 
-func (r *DefaultDNSRule) Match(metadata *adapter.InboundContext) bool {
+func (r *DefaultDNSRule) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	metadata.IgnoreDestinationIPCIDRMatch = true
 	defer func() {
 		metadata.IgnoreDestinationIPCIDRMatch = false
 	}()
-	return r.abstractDefaultRule.Match(metadata)
+	return r.abstractDefaultRule.Match(ctx, metadata)
 }
 
-func (r *DefaultDNSRule) MatchAddressLimit(metadata *adapter.InboundContext) bool {
-	return r.abstractDefaultRule.Match(metadata)
+func (r *DefaultDNSRule) MatchAddressLimit(ctx context.Context, metadata *adapter.InboundContext) bool {
+	return r.abstractDefaultRule.Match(ctx, metadata)
 }
 
 var _ adapter.DNSRule = (*LogicalDNSRule)(nil)
@@ -340,30 +341,30 @@ func (r *LogicalDNSRule) WithAddressLimit() bool {
 	return false
 }
 
-func (r *LogicalDNSRule) Match(metadata *adapter.InboundContext) bool {
+func (r *LogicalDNSRule) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.mode == C.LogicalTypeAnd {
 		return common.All(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.(adapter.DNSRule).Match(metadata)
+			return it.(adapter.DNSRule).Match(ctx, metadata)
 		}) != r.invert
 	} else {
 		return common.Any(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.(adapter.DNSRule).Match(metadata)
+			return it.(adapter.DNSRule).Match(ctx, metadata)
 		}) != r.invert
 	}
 }
 
-func (r *LogicalDNSRule) MatchAddressLimit(metadata *adapter.InboundContext) bool {
+func (r *LogicalDNSRule) MatchAddressLimit(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.mode == C.LogicalTypeAnd {
 		return common.All(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.(adapter.DNSRule).MatchAddressLimit(metadata)
+			return it.(adapter.DNSRule).MatchAddressLimit(ctx, metadata)
 		}) != r.invert
 	} else {
 		return common.Any(r.rules, func(it adapter.HeadlessRule) bool {
 			metadata.ResetRuleCache()
-			return it.(adapter.DNSRule).MatchAddressLimit(metadata)
+			return it.(adapter.DNSRule).MatchAddressLimit(ctx, metadata)
 		}) != r.invert
 	}
 }
diff --git a/route/rule_item_adguard.go b/route/rule_item_adguard.go
index bdbb3b75fda8..df672833c5e6 100644
--- a/route/rule_item_adguard.go
+++ b/route/rule_item_adguard.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewRawAdGuardDomainItem(matcher *domain.AdGuardMatcher) *AdGuardDomainItem
 	}
 }
 
-func (r *AdGuardDomainItem) Match(metadata *adapter.InboundContext) bool {
+func (r *AdGuardDomainItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var domainHost string
 	if metadata.Domain != "" {
 		domainHost = metadata.Domain
diff --git a/route/rule_item_auth_user.go b/route/rule_item_auth_user.go
index fbe053e6bec4..a6402041de83 100644
--- a/route/rule_item_auth_user.go
+++ b/route/rule_item_auth_user.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewAuthUserItem(users []string) *AuthUserItem {
 	}
 }
 
-func (r *AuthUserItem) Match(metadata *adapter.InboundContext) bool {
+func (r *AuthUserItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.userMap[metadata.User]
 }
 
diff --git a/route/rule_item_cidr.go b/route/rule_item_cidr.go
index be0bb1369c79..aed240f1eefa 100644
--- a/route/rule_item_cidr.go
+++ b/route/rule_item_cidr.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"net/netip"
 	"strings"
 
@@ -72,7 +73,7 @@ func NewRawIPCIDRItem(isSource bool, ipSet *netipx.IPSet) *IPCIDRItem {
 	}
 }
 
-func (r *IPCIDRItem) Match(metadata *adapter.InboundContext) bool {
+func (r *IPCIDRItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.isSource || metadata.IPCIDRMatchSource {
 		return r.ipSet.Contains(metadata.Source.Addr)
 	}
diff --git a/route/rule_item_clash_mode.go b/route/rule_item_clash_mode.go
index 70141f1116af..263db109c5d9 100644
--- a/route/rule_item_clash_mode.go
+++ b/route/rule_item_clash_mode.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -20,7 +21,7 @@ func NewClashModeItem(router adapter.Router, mode string) *ClashModeItem {
 	}
 }
 
-func (r *ClashModeItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ClashModeItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	clashServer := r.router.ClashServer()
 	if clashServer == nil {
 		return false
diff --git a/route/rule_item_client.go b/route/rule_item_client.go
index eeab44024010..b109f5769b6d 100644
--- a/route/rule_item_client.go
+++ b/route/rule_item_client.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewClientItem(clients []string) *ClientItem {
 	}
 }
 
-func (r *ClientItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ClientItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.clientMap[metadata.Client]
 }
 
diff --git a/route/rule_item_domain.go b/route/rule_item_domain.go
index c77890df2406..bff96f16438b 100644
--- a/route/rule_item_domain.go
+++ b/route/rule_item_domain.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -50,7 +51,7 @@ func NewRawDomainItem(matcher *domain.Matcher) *DomainItem {
 	}
 }
 
-func (r *DomainItem) Match(metadata *adapter.InboundContext) bool {
+func (r *DomainItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var domainHost string
 	if metadata.Domain != "" {
 		domainHost = metadata.Domain
diff --git a/route/rule_item_domain_keyword.go b/route/rule_item_domain_keyword.go
index c6ca1e8c28a1..c3ce215ed9f1 100644
--- a/route/rule_item_domain_keyword.go
+++ b/route/rule_item_domain_keyword.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -16,7 +17,7 @@ func NewDomainKeywordItem(keywords []string) *DomainKeywordItem {
 	return &DomainKeywordItem{keywords}
 }
 
-func (r *DomainKeywordItem) Match(metadata *adapter.InboundContext) bool {
+func (r *DomainKeywordItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var domainHost string
 	if metadata.Domain != "" {
 		domainHost = metadata.Domain
diff --git a/route/rule_item_domain_regex.go b/route/rule_item_domain_regex.go
index b3555168a276..95407eb33ace 100644
--- a/route/rule_item_domain_regex.go
+++ b/route/rule_item_domain_regex.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"regexp"
 	"strings"
 
@@ -37,7 +38,7 @@ func NewDomainRegexItem(expressions []string) (*DomainRegexItem, error) {
 	return &DomainRegexItem{matchers, description}, nil
 }
 
-func (r *DomainRegexItem) Match(metadata *adapter.InboundContext) bool {
+func (r *DomainRegexItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var domainHost string
 	if metadata.Domain != "" {
 		domainHost = metadata.Domain
diff --git a/route/rule_item_geoip.go b/route/rule_item_geoip.go
index 3611613a48c8..6bf5c46abe17 100644
--- a/route/rule_item_geoip.go
+++ b/route/rule_item_geoip.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"net/netip"
 	"strings"
 
@@ -33,7 +34,7 @@ func NewGeoIPItem(router adapter.Router, logger log.ContextLogger, isSource bool
 	}
 }
 
-func (r *GeoIPItem) Match(metadata *adapter.InboundContext) bool {
+func (r *GeoIPItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var geoipCode string
 	if r.isSource && metadata.SourceGeoIPCode != "" {
 		geoipCode = metadata.SourceGeoIPCode
diff --git a/route/rule_item_geosite.go b/route/rule_item_geosite.go
index 5fdbfe596295..6ec2637bd9d6 100644
--- a/route/rule_item_geosite.go
+++ b/route/rule_item_geosite.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -38,9 +39,9 @@ func (r *GeositeItem) Update() error {
 	return nil
 }
 
-func (r *GeositeItem) Match(metadata *adapter.InboundContext) bool {
+func (r *GeositeItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	for _, matcher := range r.matchers {
-		if matcher.Match(metadata) {
+		if matcher.Match(ctx, metadata) {
 			return true
 		}
 	}
diff --git a/route/rule_item_inbound.go b/route/rule_item_inbound.go
index 7e28781f00d8..34fce4becd79 100644
--- a/route/rule_item_inbound.go
+++ b/route/rule_item_inbound.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -22,7 +23,7 @@ func NewInboundRule(inbounds []string) *InboundItem {
 	return rule
 }
 
-func (r *InboundItem) Match(metadata *adapter.InboundContext) bool {
+func (r *InboundItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.inboundMap[metadata.Inbound]
 }
 
diff --git a/route/rule_item_ip_is_private.go b/route/rule_item_ip_is_private.go
index 6592a9d3fe03..b13146107e96 100644
--- a/route/rule_item_ip_is_private.go
+++ b/route/rule_item_ip_is_private.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"net/netip"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -17,7 +18,7 @@ func NewIPIsPrivateItem(isSource bool) *IPIsPrivateItem {
 	return &IPIsPrivateItem{isSource}
 }
 
-func (r *IPIsPrivateItem) Match(metadata *adapter.InboundContext) bool {
+func (r *IPIsPrivateItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var destination netip.Addr
 	if r.isSource {
 		destination = metadata.Source.Addr
diff --git a/route/rule_item_ipversion.go b/route/rule_item_ipversion.go
index 3d8762b41711..c36a4a5fc5cb 100644
--- a/route/rule_item_ipversion.go
+++ b/route/rule_item_ipversion.go
@@ -1,6 +1,8 @@
 package route
 
 import (
+	"context"
+
 	"github.com/sagernet/sing-box/adapter"
 )
 
@@ -14,7 +16,7 @@ func NewIPVersionItem(isIPv6 bool) *IPVersionItem {
 	return &IPVersionItem{isIPv6}
 }
 
-func (r *IPVersionItem) Match(metadata *adapter.InboundContext) bool {
+func (r *IPVersionItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return metadata.IPVersion != 0 && metadata.IPVersion == 6 == r.isIPv6 ||
 		metadata.Destination.IsIP() && metadata.Destination.IsIPv6() == r.isIPv6
 }
diff --git a/route/rule_item_network.go b/route/rule_item_network.go
index fc54f425da68..eeca97b7832a 100644
--- a/route/rule_item_network.go
+++ b/route/rule_item_network.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewNetworkItem(networks []string) *NetworkItem {
 	}
 }
 
-func (r *NetworkItem) Match(metadata *adapter.InboundContext) bool {
+func (r *NetworkItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.networkMap[metadata.Network]
 }
 
diff --git a/route/rule_item_outbound.go b/route/rule_item_outbound.go
index 4b3e16fc6bc2..5367bcc5a922 100644
--- a/route/rule_item_outbound.go
+++ b/route/rule_item_outbound.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -27,7 +28,7 @@ func NewOutboundRule(outbounds []string) *OutboundItem {
 	return rule
 }
 
-func (r *OutboundItem) Match(metadata *adapter.InboundContext) bool {
+func (r *OutboundItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.matchAny && metadata.Outbound != "" {
 		return true
 	}
diff --git a/route/rule_item_package_name.go b/route/rule_item_package_name.go
index d1ca09eb2d42..9ab72f42f212 100644
--- a/route/rule_item_package_name.go
+++ b/route/rule_item_package_name.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -24,7 +25,7 @@ func NewPackageNameItem(packageNameList []string) *PackageNameItem {
 	return rule
 }
 
-func (r *PackageNameItem) Match(metadata *adapter.InboundContext) bool {
+func (r *PackageNameItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.PackageName == "" {
 		return false
 	}
diff --git a/route/rule_item_port.go b/route/rule_item_port.go
index 624789336444..04ec3d3e0d7f 100644
--- a/route/rule_item_port.go
+++ b/route/rule_item_port.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -27,7 +28,7 @@ func NewPortItem(isSource bool, ports []uint16) *PortItem {
 	}
 }
 
-func (r *PortItem) Match(metadata *adapter.InboundContext) bool {
+func (r *PortItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if r.isSource {
 		return r.portMap[metadata.Source.Port]
 	} else {
diff --git a/route/rule_item_port_range.go b/route/rule_item_port_range.go
index f87575f2ce3c..7543a0658029 100644
--- a/route/rule_item_port_range.go
+++ b/route/rule_item_port_range.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strconv"
 	"strings"
 
@@ -55,7 +56,7 @@ func NewPortRangeItem(isSource bool, rangeList []string) (*PortRangeItem, error)
 	}, nil
 }
 
-func (r *PortRangeItem) Match(metadata *adapter.InboundContext) bool {
+func (r *PortRangeItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	var port uint16
 	if r.isSource {
 		port = metadata.Source.Port
diff --git a/route/rule_item_process_name.go b/route/rule_item_process_name.go
index ce051666d04a..7e82f48baddd 100644
--- a/route/rule_item_process_name.go
+++ b/route/rule_item_process_name.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"path/filepath"
 	"strings"
 
@@ -25,7 +26,7 @@ func NewProcessItem(processNameList []string) *ProcessItem {
 	return rule
 }
 
-func (r *ProcessItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ProcessItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.ProcessPath == "" {
 		return false
 	}
diff --git a/route/rule_item_process_path.go b/route/rule_item_process_path.go
index feae4b275601..299d45dfafd1 100644
--- a/route/rule_item_process_path.go
+++ b/route/rule_item_process_path.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -24,7 +25,7 @@ func NewProcessPathItem(processNameList []string) *ProcessPathItem {
 	return rule
 }
 
-func (r *ProcessPathItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ProcessPathItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.ProcessPath == "" {
 		return false
 	}
diff --git a/route/rule_item_process_path_regex.go b/route/rule_item_process_path_regex.go
index 01b2723cc6fa..0080644e2486 100644
--- a/route/rule_item_process_path_regex.go
+++ b/route/rule_item_process_path_regex.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"regexp"
 	"strings"
 
@@ -37,7 +38,7 @@ func NewProcessPathRegexItem(expressions []string) (*ProcessPathRegexItem, error
 	return &ProcessPathRegexItem{matchers, description}, nil
 }
 
-func (r *ProcessPathRegexItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ProcessPathRegexItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.ProcessPath == "" {
 		return false
 	}
diff --git a/route/rule_item_protocol.go b/route/rule_item_protocol.go
index 1988f8ade1c2..fd3e4090f877 100644
--- a/route/rule_item_protocol.go
+++ b/route/rule_item_protocol.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewProtocolItem(protocols []string) *ProtocolItem {
 	}
 }
 
-func (r *ProtocolItem) Match(metadata *adapter.InboundContext) bool {
+func (r *ProtocolItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.protocolMap[metadata.Protocol]
 }
 
diff --git a/route/rule_item_query_type.go b/route/rule_item_query_type.go
index 7b6efdd04499..d7a68a2069ca 100644
--- a/route/rule_item_query_type.go
+++ b/route/rule_item_query_type.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -28,7 +29,7 @@ func NewQueryTypeItem(typeList []option.DNSQueryType) *QueryTypeItem {
 	return rule
 }
 
-func (r *QueryTypeItem) Match(metadata *adapter.InboundContext) bool {
+func (r *QueryTypeItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.QueryType == 0 {
 		return false
 	}
diff --git a/route/rule_item_rule_set.go b/route/rule_item_rule_set.go
index b80fca995c45..8551cc13609d 100644
--- a/route/rule_item_rule_set.go
+++ b/route/rule_item_rule_set.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -40,11 +41,11 @@ func (r *RuleSetItem) Start() error {
 	return nil
 }
 
-func (r *RuleSetItem) Match(metadata *adapter.InboundContext) bool {
+func (r *RuleSetItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	metadata.IPCIDRMatchSource = r.ipCidrMatchSource
 	metadata.IPCIDRAcceptEmpty = r.ipCidrAcceptEmpty
 	for _, ruleSet := range r.setList {
-		if ruleSet.Match(metadata) {
+		if ruleSet.Match(ctx, metadata) {
 			return true
 		}
 	}
diff --git a/route/rule_item_user.go b/route/rule_item_user.go
index bed97fbaa611..f931b5d67edd 100644
--- a/route/rule_item_user.go
+++ b/route/rule_item_user.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewUserItem(users []string) *UserItem {
 	}
 }
 
-func (r *UserItem) Match(metadata *adapter.InboundContext) bool {
+func (r *UserItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.User == "" {
 		return false
 	}
diff --git a/route/rule_item_user_id.go b/route/rule_item_user_id.go
index 43ab704e3aa3..3a8059383347 100644
--- a/route/rule_item_user_id.go
+++ b/route/rule_item_user_id.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -25,7 +26,7 @@ func NewUserIDItem(userIdList []int32) *UserIdItem {
 	return rule
 }
 
-func (r *UserIdItem) Match(metadata *adapter.InboundContext) bool {
+func (r *UserIdItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	if metadata.ProcessInfo == nil || metadata.ProcessInfo.UserId == -1 {
 		return false
 	}
diff --git a/route/rule_item_wifi_bssid.go b/route/rule_item_wifi_bssid.go
index 3b1ff9c852a3..4a17eb73ae42 100644
--- a/route/rule_item_wifi_bssid.go
+++ b/route/rule_item_wifi_bssid.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -27,7 +28,7 @@ func NewWIFIBSSIDItem(router adapter.Router, bssidList []string) *WIFIBSSIDItem
 	}
 }
 
-func (r *WIFIBSSIDItem) Match(metadata *adapter.InboundContext) bool {
+func (r *WIFIBSSIDItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.bssidMap[r.router.WIFIState().BSSID]
 }
 
diff --git a/route/rule_item_wifi_ssid.go b/route/rule_item_wifi_ssid.go
index 62cf935eb0a2..43b436d24e5e 100644
--- a/route/rule_item_wifi_ssid.go
+++ b/route/rule_item_wifi_ssid.go
@@ -1,6 +1,7 @@
 package route
 
 import (
+	"context"
 	"strings"
 
 	"github.com/sagernet/sing-box/adapter"
@@ -27,7 +28,7 @@ func NewWIFISSIDItem(router adapter.Router, ssidList []string) *WIFISSIDItem {
 	}
 }
 
-func (r *WIFISSIDItem) Match(metadata *adapter.InboundContext) bool {
+func (r *WIFISSIDItem) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	return r.ssidMap[r.router.WIFIState().SSID]
 }
 
diff --git a/route/rule_set_local.go b/route/rule_set_local.go
index 893842d5cce5..07939272d6e2 100644
--- a/route/rule_set_local.go
+++ b/route/rule_set_local.go
@@ -184,9 +184,9 @@ func (s *LocalRuleSet) Close() error {
 	return common.Close(common.PtrOrNil(s.watcher))
 }
 
-func (s *LocalRuleSet) Match(metadata *adapter.InboundContext) bool {
+func (s *LocalRuleSet) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	for _, rule := range s.rules {
-		if rule.Match(metadata) {
+		if rule.Match(ctx, metadata) {
 			return true
 		}
 	}
diff --git a/route/rule_set_remote.go b/route/rule_set_remote.go
index 03662ee42c46..5a9bfb47875a 100644
--- a/route/rule_set_remote.go
+++ b/route/rule_set_remote.go
@@ -312,9 +312,9 @@ func (s *RemoteRuleSet) Close() error {
 	return nil
 }
 
-func (s *RemoteRuleSet) Match(metadata *adapter.InboundContext) bool {
+func (s *RemoteRuleSet) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
 	for _, rule := range s.rules {
-		if rule.Match(metadata) {
+		if rule.Match(ctx, metadata) {
 			return true
 		}
 	}
-- 
2.47.0

