From c2d7b8ceef910b2c1ac53f075a2e2b5acae5a83a Mon Sep 17 00:00:00 2001
From: Ivan Mironov <mironov.ivan@gmail.com>
Date: Fri, 18 Oct 2024 20:25:29 +0200
Subject: [PATCH 3/4] Support resolving domain addresses while matching rules

---
 adapter/inbound.go            |  7 ++++
 option/rule.go                |  1 +
 option/rule_set.go            |  1 +
 route/router.go               |  4 +++
 route/router_dns.go           |  4 +++
 route/rule_abstract.go        |  9 ++++++
 route/rule_default.go         |  4 +++
 route/rule_domain_strategy.go | 61 +++++++++++++++++++++++++++++++++++
 route/rule_headless.go        |  6 ++++
 9 files changed, 97 insertions(+)
 create mode 100644 route/rule_domain_strategy.go

diff --git a/adapter/inbound.go b/adapter/inbound.go
index ffc4c5645499..fa22f74d0922 100644
--- a/adapter/inbound.go
+++ b/adapter/inbound.go
@@ -7,6 +7,7 @@ import (
 
 	"github.com/sagernet/sing-box/common/process"
 	"github.com/sagernet/sing-box/option"
+	dns "github.com/sagernet/sing-dns"
 	M "github.com/sagernet/sing/common/metadata"
 	N "github.com/sagernet/sing/common/network"
 )
@@ -54,6 +55,12 @@ type InboundContext struct {
 	QueryType            uint16
 	FakeIP               bool
 
+	// rule domain strategy
+
+	DomainResolutionFailed   bool
+	InsideDomainStrategyRule bool
+	AppliedDomainStrategy    dns.DomainStrategy
+
 	// rule cache
 
 	IPCIDRMatchSource bool
diff --git a/option/rule.go b/option/rule.go
index 5f15645c9be1..8289fdd0befb 100644
--- a/option/rule.go
+++ b/option/rule.go
@@ -65,6 +65,7 @@ func (r Rule) IsValid() bool {
 }
 
 type _DefaultRule struct {
+	DomainStrategy           DomainStrategy   `json:"domain_strategy,omitempty"`
 	Inbound                  Listable[string] `json:"inbound,omitempty"`
 	IPVersion                int              `json:"ip_version,omitempty"`
 	Network                  Listable[string] `json:"network,omitempty"`
diff --git a/option/rule_set.go b/option/rule_set.go
index b6ec113e35b8..91cd7f19eea9 100644
--- a/option/rule_set.go
+++ b/option/rule_set.go
@@ -144,6 +144,7 @@ func (r HeadlessRule) IsValid() bool {
 }
 
 type DefaultHeadlessRule struct {
+	DomainStrategy   DomainStrategy         `json:"domain_strategy,omitempty"`
 	QueryType        Listable[DNSQueryType] `json:"query_type,omitempty"`
 	Network          Listable[string]       `json:"network,omitempty"`
 	Domain           Listable[string]       `json:"domain,omitempty"`
diff --git a/route/router.go b/route/router.go
index 4f46273605a8..185a41076bdf 100644
--- a/route/router.go
+++ b/route/router.go
@@ -1151,6 +1151,10 @@ func (r *Router) match0(ctx context.Context, metadata *adapter.InboundContext, d
 	for i, rule := range r.rules {
 		metadata.ResetRuleCache()
 		if rule.Match(ctx, metadata) {
+			if metadata.DomainResolutionFailed {
+				break
+			}
+
 			detour := rule.Outbound()
 			r.logger.DebugContext(ctx, "match[", i, "] ", rule.String(), " => ", detour)
 			if outbound, loaded := r.Outbound(detour); loaded {
diff --git a/route/router_dns.go b/route/router_dns.go
index 40477adb4bd6..879dbea1cd1e 100644
--- a/route/router_dns.go
+++ b/route/router_dns.go
@@ -52,6 +52,10 @@ func (r *Router) matchDNS(ctx context.Context, allowFakeIP bool, index int, isAd
 			}
 			metadata.ResetRuleCache()
 			if rule.Match(ctx, metadata) {
+				if metadata.DomainResolutionFailed {
+					break
+				}
+
 				detour := rule.Outbound()
 				transport, loaded := r.transportMap[detour]
 				if !loaded {
diff --git a/route/rule_abstract.go b/route/rule_abstract.go
index a9e9d4a19530..41d80e2b83a4 100644
--- a/route/rule_abstract.go
+++ b/route/rule_abstract.go
@@ -12,6 +12,7 @@ import (
 )
 
 type abstractDefaultRule struct {
+	domainStrategy          *RuleDomainStrategy
 	items                   []RuleItem
 	sourceAddressItems      []RuleItem
 	sourcePortItems         []RuleItem
@@ -65,6 +66,14 @@ func (r *abstractDefaultRule) UpdateGeosite() error {
 }
 
 func (r *abstractDefaultRule) Match(ctx context.Context, metadata *adapter.InboundContext) bool {
+	if r.domainStrategy != nil {
+		if !r.domainStrategy.Resolve(ctx, metadata) {
+			// Mandatory domain resolution failed => no match, stop processing and use default outbound.
+			metadata.DomainResolutionFailed = true
+			return true
+		}
+	}
+
 	if len(r.allItems) == 0 {
 		return true
 	}
diff --git a/route/rule_default.go b/route/rule_default.go
index 6f38fa54a730..67517722c7d0 100644
--- a/route/rule_default.go
+++ b/route/rule_default.go
@@ -7,6 +7,7 @@ import (
 	C "github.com/sagernet/sing-box/constant"
 	"github.com/sagernet/sing-box/log"
 	"github.com/sagernet/sing-box/option"
+	dns "github.com/sagernet/sing-dns"
 	E "github.com/sagernet/sing/common/exceptions"
 )
 
@@ -51,6 +52,9 @@ func NewDefaultRule(router adapter.Router, logger log.ContextLogger, options opt
 			outbound: options.Outbound,
 		},
 	}
+	if dns.DomainStrategy(options.DomainStrategy) != dns.DomainStrategyAsIS {
+		rule.domainStrategy = NewRuleDomainStrategy(router, logger, dns.DomainStrategy(options.DomainStrategy))
+	}
 	if len(options.Inbound) > 0 {
 		item := NewInboundRule(options.Inbound)
 		rule.items = append(rule.items, item)
diff --git a/route/rule_domain_strategy.go b/route/rule_domain_strategy.go
new file mode 100644
index 000000000000..a36767ee5a96
--- /dev/null
+++ b/route/rule_domain_strategy.go
@@ -0,0 +1,61 @@
+package route
+
+import (
+	"context"
+	"strings"
+
+	"github.com/sagernet/sing-box/adapter"
+	"github.com/sagernet/sing-box/log"
+	dns "github.com/sagernet/sing-dns"
+	F "github.com/sagernet/sing/common/format"
+)
+
+type RuleDomainStrategy struct {
+	router         adapter.Router
+	logger         log.ContextLogger
+	domainStrategy dns.DomainStrategy
+}
+
+func NewRuleDomainStrategy(router adapter.Router, logger log.ContextLogger, domain_strategy dns.DomainStrategy) *RuleDomainStrategy {
+	return &RuleDomainStrategy{
+		router:         router,
+		logger:         logger,
+		domainStrategy: domain_strategy,
+	}
+}
+
+func (r *RuleDomainStrategy) Resolve(ctx context.Context, metadata *adapter.InboundContext) bool {
+	if metadata.InsideDomainStrategyRule {
+		// Recursion detected: used within DNS rules
+		r.logger.Error("domain_strategy is not supported within DNS rules")
+		return false
+	} else if metadata.AppliedDomainStrategy == r.domainStrategy {
+		// Already resolved using the same strategy
+		return true
+	} else if metadata.Destination.IsFqdn() && r.domainStrategy != dns.DomainStrategyAsIS {
+		var newMetadata adapter.InboundContext
+		newMetadata = *metadata
+		newMetadata.ResetRuleCache()
+		newMetadata.InsideDomainStrategyRule = true
+
+		addresses, err := r.router.Lookup(adapter.WithContext(ctx, &newMetadata), metadata.Destination.Fqdn, r.domainStrategy)
+		if err == nil {
+			metadata.DestinationAddresses = addresses
+			r.logger.Debug("rule resolved ", metadata.Destination.Fqdn, " => [", strings.Join(F.MapToString(metadata.DestinationAddresses), " "), "]")
+			metadata.AppliedDomainStrategy = r.domainStrategy
+			return true
+		} else {
+			r.logger.Error("rule failed to resolve ", metadata.Destination.Fqdn, " addresses: ", err)
+			metadata.AppliedDomainStrategy = dns.DomainStrategyAsIS
+			return false
+		}
+	} else if metadata.Destination.IsIP() || len(metadata.DestinationAddresses) > 0 {
+		// No FQDN, but we already have addresses => no need to resolve
+		metadata.AppliedDomainStrategy = dns.DomainStrategyAsIS
+		return true
+	} else {
+		r.logger.Error("rule failed to resolve addresses: no FQDN")
+		metadata.AppliedDomainStrategy = dns.DomainStrategyAsIS
+		return false
+	}
+}
diff --git a/route/rule_headless.go b/route/rule_headless.go
index 3d67900453ce..c635ebb5137b 100644
--- a/route/rule_headless.go
+++ b/route/rule_headless.go
@@ -5,6 +5,7 @@ import (
 	C "github.com/sagernet/sing-box/constant"
 	"github.com/sagernet/sing-box/log"
 	"github.com/sagernet/sing-box/option"
+	dns "github.com/sagernet/sing-dns"
 	E "github.com/sagernet/sing/common/exceptions"
 )
 
@@ -37,6 +38,11 @@ func NewDefaultHeadlessRule(router adapter.Router, logger log.ContextLogger, opt
 			invert: options.Invert,
 		},
 	}
+	if dns.DomainStrategy(options.DomainStrategy) != dns.DomainStrategyAsIS {
+		if router != nil {
+			rule.domainStrategy = NewRuleDomainStrategy(router, logger, dns.DomainStrategy(options.DomainStrategy))
+		}
+	}
 	if len(options.Network) > 0 {
 		item := NewNetworkItem(options.Network)
 		rule.items = append(rule.items, item)
-- 
2.47.0

